# Auth Feature User Model - Implementation Guide

**Version:** 1.0  
**Date:** January 2025  
**Status:** ✅ Complete - All tests passing (115/115)

---

## Overview

The auth feature has been refactored to include a **User domain model** (`src/features/auth/models/user.ts`) that encapsulates user-related business logic, following the same pattern as the new CRUD features generated by `create-feature.ts`.

### What Changed

**Before (Data + Services Pattern):**

```
auth/
├── data/          # Pure database access
│   └── user.ts    # ❌ Had business logic (bcrypt password verification)
├── services/      # Orchestration + Business Logic
│   ├── login-user.ts
│   └── register-user.ts  # ❌ Had direct bcrypt calls
└── (no models/)   # ❌ Missing domain model layer
```

**After (Data + Models + Services Pattern):**

```
auth/
├── models/        # ✅ NEW: Domain entity classes with business logic
│   ├── user.ts    # ✅ User model with password methods
│   └── index.ts   # Barrel export
├── data/          # ✅ Pure database access (no business logic)
│   └── user.ts    # ✅ Returns PrismaUser, uses User model for verification
├── services/      # ✅ Orchestration only (uses User model)
│   ├── login-user.ts         # ✅ Uses User model
│   ├── register-user.ts      # ✅ Uses User.hashPassword()
│   └── update-password.ts    # ✅ Uses User.hashPassword()
```

---

## User Model Features

### Class Structure

```typescript
import { User } from '@/features/auth/models';

// Create from Prisma user data
const prismaUser = await getUserByEmail('user@example.com');
const user = new User(prismaUser);
```

### Instance Properties (Getters)

```typescript
user.id; // string
user.email; // string
user.name; // string | null
user.role; // string
user.emailVerified; // Date | null
user.image; // string | null
user.createdAt; // Date
user.updatedAt; // Date
```

### Instance Methods

```typescript
// Check email verification
user.isEmailVerified(); // boolean

// Check user role
user.hasRole('ADMIN'); // boolean

// Verify password (async, uses bcrypt)
await user.verifyPassword('plainPassword'); // Promise<boolean>

// Safe serialization (removes password)
user.toSafeObject(); // Omit<PrismaUser, 'password'>

// Get raw Prisma data
user.toPrisma(); // PrismaUser
```

### Static Methods

```typescript
// Hash password (used during user creation)
const hashedPassword = await User.hashPassword('plainPassword');

// Validate password strength
User.isValidPassword('mypass123'); // boolean

// Validate email format
User.isValidEmail('user@example.com'); // boolean
```

---

## Refactored Components

### 1. Data Layer (`data/user.ts`)

**Changes:**

- Import `User` model from `@/features/auth/models`
- Change `import type { User }` to `import type { User as PrismaUser }`
- Update return types: `User` → `PrismaUser`
- `verifyUserCredentials()` now uses `User` model for password verification

**Before:**

```typescript
import type { User } from '@prisma/client';
import bcrypt from 'bcryptjs';

export const verifyUserCredentials = async (
  email: string,
  password: string
) => {
  const user = await getUserByEmail(email);
  if (!user || !user.password) return null;

  // ❌ Business logic in data layer
  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) return null;

  const { password: _, ...userWithoutPassword } = user;
  return userWithoutPassword;
};
```

**After:**

```typescript
import type { User as PrismaUser } from '@prisma/client';

import { User } from '@/features/auth/models';

export const verifyUserCredentials = async (
  email: string,
  password: string
) => {
  const prismaUser = await getUserByEmail(email);
  if (!prismaUser) return null;

  // ✅ Business logic in User model
  const user = new User(prismaUser);
  const isValid = await user.verifyPassword(password);
  if (!isValid) return null;

  // ✅ Use model method
  return user.toSafeObject();
};
```

---

### 2. Register Service (`services/register-user.ts`)

**Changes:**

- Remove `import bcrypt from 'bcryptjs'`
- Remove `import { BCRYPT_SALT_ROUNDS }`
- Add `import { User } from '@/features/auth/models'`
- Replace `bcrypt.hash()` with `User.hashPassword()`

**Before:**

```typescript
import bcrypt from 'bcryptjs';

import { BCRYPT_SALT_ROUNDS } from '@/features/auth/lib/constants';

export const registerUser = async (values: RegisterInput) => {
  // ... validation ...

  // ❌ Direct bcrypt usage (business logic in service)
  const hashedPassword = await bcrypt.hash(password, BCRYPT_SALT_ROUNDS);

  const createdUser = await db.user.create({
    data: { name, email, password: hashedPassword },
  });

  // ...
};
```

**After:**

```typescript
import { User } from '@/features/auth/models';

export const registerUser = async (values: RegisterInput) => {
  // ... validation ...

  // ✅ Use User model static method
  const hashedPassword = await User.hashPassword(password);

  const createdUser = await db.user.create({
    data: { name, email, password: hashedPassword },
  });

  // ...
};
```

---

### 3. Update Password Service (`services/update-password.ts`)

**Changes:**

- Remove `import bcrypt from 'bcryptjs'`
- Remove `import { BCRYPT_SALT_ROUNDS }`
- Add `import { User } from '@/features/auth/models'`
- Replace `bcrypt.hash()` with `User.hashPassword()`

**Before:**

```typescript
import bcrypt from 'bcryptjs';

import { BCRYPT_SALT_ROUNDS } from '@/features/auth/lib/constants';

export const updatePassword = async (values: NewPasswordInput) => {
  // ... token validation ...

  // ❌ Direct bcrypt usage
  const hashedPassword = await bcrypt.hash(password, BCRYPT_SALT_ROUNDS);

  await db.$transaction([
    db.user.update({
      where: { id: existingUser.id },
      data: { password: hashedPassword },
    }),
    // ...
  ]);
};
```

**After:**

```typescript
import { User } from '@/features/auth/models';

export const updatePassword = async (values: NewPasswordInput) => {
  // ... token validation ...

  // ✅ Use User model static method
  const hashedPassword = await User.hashPassword(password);

  await db.$transaction([
    db.user.update({
      where: { id: existingUser.id },
      data: { password: hashedPassword },
    }),
    // ...
  ]);
};
```

---

## Benefits

### 1. **Separation of Concerns**

- ✅ **Data Layer**: Pure database access (no bcrypt)
- ✅ **Models Layer**: Business logic (password hashing, validation)
- ✅ **Services Layer**: Orchestration (uses models)

### 2. **Consistency**

- ✅ Matches new CRUD features generated by `create-feature.ts`
- ✅ Follows enterprise patterns from guidelines

### 3. **Testability**

- ✅ Easier to unit test `User.hashPassword()` and `user.verifyPassword()`
- ✅ Mock User model instead of mocking bcrypt directly

### 4. **Maintainability**

- ✅ Single source of truth for password operations
- ✅ Easy to change hashing algorithm (only update User model)
- ✅ Clear domain logic location

### 5. **Type Safety**

- ✅ Explicit `PrismaUser` vs `User` (model class) types
- ✅ No more `User` type conflicts between Prisma and model

---

## When to Use User Model

### ✅ Use User Model When:

1. **Password Operations**

   ```typescript
   // Hash password before creating user
   const hashedPassword = await User.hashPassword(password);

   // Verify password during login
   const user = new User(prismaUser);
   const isValid = await user.verifyPassword(password);
   ```

2. **Business Logic Checks**

   ```typescript
   const user = new User(prismaUser);

   if (!user.isEmailVerified()) {
     // Send verification email
   }

   if (user.hasRole('ADMIN')) {
     // Allow admin action
   }
   ```

3. **Safe Serialization**

   ```typescript
   const user = new User(prismaUser);

   // Return to client without password
   return response.success({ data: user.toSafeObject() });
   ```

### ❌ Don't Use User Model When:

1. **Direct Database Queries**

   ```typescript
   // ✅ Data layer returns PrismaUser
   const prismaUser = await getUserByEmail(email);

   // ❌ Don't wrap unnecessarily if you only need data
   const user = new User(prismaUser);
   return user.id; // Just use prismaUser.id
   ```

2. **Simple Data Access**
   ```typescript
   // ✅ Simple lookups don't need model
   const userId = session.user.id;
   const prismaUser = await getUserById(userId);
   ```

---

## Testing

All 115 tests pass, including:

- ✅ `user.test.ts` (17 tests) - Data layer with User model
- ✅ `login-action.test.ts` (4 tests)
- ✅ `register-action.test.ts` (5 tests)
- ✅ `update-password-action.test.ts` (9 tests)
- ✅ All other auth tests (75 tests)

---

## Future Enhancements

The User model provides a foundation for future business logic:

```typescript
// Example future additions
class User {
  // Role-based permissions
  canManageUsers(): boolean {
    return this.hasRole('ADMIN') || this.hasRole('SUPER_ADMIN');
  }

  // Account status
  isAccountLocked(): boolean {
    return this.status === 'LOCKED';
  }

  // Complex validation
  canChangeEmail(newEmail: string): boolean {
    return this.isEmailVerified() && User.isValidEmail(newEmail);
  }

  // Computed properties
  get displayName(): string {
    return this.name || this.email.split('@')[0];
  }
}
```

---

## Migration Checklist

When applying this pattern to other features:

- [ ] Create `models/` folder with domain entity class
- [ ] Move business logic from data layer to model
- [ ] Update data layer to return Prisma types (not model instances)
- [ ] Update services to use model methods
- [ ] Add `as const` to model for immutability
- [ ] Export model from `models/index.ts` barrel file
- [ ] Update imports: `User` → `User as PrismaUser` in data layer
- [ ] Run tests to ensure no regressions
- [ ] Update documentation

---

## Conclusion

The auth feature now follows the same **Data + Models + Services** pattern as new CRUD features, with:

- ✅ Clean separation of concerns
- ✅ Business logic in User model
- ✅ Type-safe PrismaUser vs User (model) distinction
- ✅ All 115 tests passing
- ✅ Consistent with project guidelines
- ✅ Ready for future enhancements
